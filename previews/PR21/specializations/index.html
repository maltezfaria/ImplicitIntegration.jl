<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Specializations · ImplicitIntegration.jl</title><meta name="title" content="Specializations · ImplicitIntegration.jl"/><meta property="og:title" content="Specializations · ImplicitIntegration.jl"/><meta property="twitter:title" content="Specializations · ImplicitIntegration.jl"/><meta name="description" content="Documentation for ImplicitIntegration.jl."/><meta property="og:description" content="Documentation for ImplicitIntegration.jl."/><meta property="twitter:description" content="Documentation for ImplicitIntegration.jl."/><meta property="og:url" content="https://maltezfaria.github.io/ImplicitIntegration.jl/specializations/"/><meta property="twitter:url" content="https://maltezfaria.github.io/ImplicitIntegration.jl/specializations/"/><link rel="canonical" href="https://maltezfaria.github.io/ImplicitIntegration.jl/specializations/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">ImplicitIntegration.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>Specializations</a><ul class="internal"><li><a class="tocitem" href="#interface"><span>Interface</span></a></li><li><a class="tocitem" href="#bernstein-polynomials"><span>Bernstein polynomials</span></a></li></ul></li><li><a class="tocitem" href="../docstrings/">Docstrings</a></li><li><a class="tocitem" href="../bibliography/">Bibliography</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Specializations</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Specializations</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/maltezfaria/ImplicitIntegration.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/maltezfaria/ImplicitIntegration.jl/blob/main/docs/src/specializations.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="specializations"><a class="docs-heading-anchor" href="#specializations">Specializations</a><a id="specializations-1"></a><a class="docs-heading-anchor-permalink" href="#specializations" title="Permalink"></a></h1><details class="admonition is-details" id="Importance-of-tight-bounds-1db35e44d9e8fe75"><summary class="admonition-header">Importance of tight bounds<a class="admonition-anchor" href="#Importance-of-tight-bounds-1db35e44d9e8fe75" title="Permalink"></a></summary><div class="admonition-body"><p>The algorithm for implicit integration is described in [<a href="../bibliography/#saye2015high">1</a>] relies on the ability to compute bounds on the implicit function and its derivatives over a hyper-rectangle. Bounds on the implicit function are used to determine whether a box is empty or full, in which case a subdivision is not necessary. Bounds on the gradient are used to determine if a height direction exists for the dimensional reduction step, in which case the problem is recursively reduced to a lower dimension. If the algorithm is unable to prove that a box is empty, full, or that a height direction exists, it subdivides the box and repeats the process on the sub-boxes. The tightness of the bounds therefore directly affects the efficiency of the algorithm, as tighter bounds lead to fewer subdivisions.</p></div></details><p><code>ImplicitIntegration</code> provides a generic method for bounding functions and their derivatives using automatic differentiation via <code>ForwardDiff</code> and range estimation with <code>IntervalArithmetic</code>. While this approach has the advantage of being rather generic, the resulting bounds are often conservative and may lead to unnecessary subdivisions during the quadrature generation process.</p><p>For specific classes of functions, we can leverage additional mathematical properties to compute tighter bounds more efficiently. These specialized bounds can significantly improve the performance of implicit integration, reducing both the computational cost and the number of quadrature points needed for accurate results.</p><p>This section describes the interface for implementing custom bounds for specific function types, and discuss one such specialization already implemented in the package: Bernstein polynomials.</p><h2 id="interface"><a class="docs-heading-anchor" href="#interface">Interface</a><a id="interface-1"></a><a class="docs-heading-anchor-permalink" href="#interface" title="Permalink"></a></h2><p>To implement specialized bounds for a specific function type, you need to overload the following methods:</p><ul><li><a href="../docstrings/#ImplicitIntegration.bound-Tuple{Any, Any, Any}"><code>bound(f::MyType, lc, hc) --&gt; (fmin, fmax)</code></a>: Compute bounds for the function <code>f</code> over the hyperrectangle defined by lower corner <code>lc</code> and upper corner <code>hc</code>.</li><li><a href="../docstrings/#ImplicitIntegration.gradient-Tuple{Any}"><code>gradient(f::MyType) --&gt; ∇f</code></a>: Compute the gradient of the function <code>f</code> as a function. The returned object <code>∇f</code> should support evaluation on the form <code>∇f(x)</code> where <code>x</code> is a point in the domain of <code>f</code>, and <code>bound(∇f, lc, hc)</code>.</li><li><a href="../docstrings/#ImplicitIntegration.project-Tuple{Any, Any, Any}"><code>project(f, k, v)</code></a>: Project the function <code>f</code> onto the <code>k</code>-th coordinate using the value <code>v</code>. The returned object should support <code>bound</code>, <code>gradient</code>, and <code>project</code> methods, allowing it to be used in the same way as the original function.</li><li><a href="../docstrings/#ImplicitIntegration.split-NTuple{4, Any}"><code>split(f, lb, ub, dir) --&gt; fₗ, fᵤ</code></a>: Split the function <code>f</code> along the specified direction <code>dir</code> into two parts, one for the lower half and one for the upper half of the hyperrectangle defined by <code>lb</code> and <code>ub</code>. The returned objects should also support <code>bound</code>, <code>gradient</code>, and <code>project</code> methods.</li></ul><div class="admonition is-success" id="Disabling-default-implementations-4db74e50d0244cd0"><header class="admonition-header">Disabling default implementations<a class="admonition-anchor" href="#Disabling-default-implementations-4db74e50d0244cd0" title="Permalink"></a></header><div class="admonition-body"><p>When implementing the interface for a specific function type, you may want to disable the default implementations provided by <code>ImplicitIntegration</code> to make sure you have correctly overloaded the proper methods. You can do this by calling <a href="../docstrings/#ImplicitIntegration.disable_default_interface-Tuple{}"><code>disable_default_interface()</code></a>. To re-enable the default interface, use <a href="../docstrings/#ImplicitIntegration.enable_default_interface-Tuple{}"><code>enable_default_interface()</code></a>.</p></div></div><h2 id="bernstein-polynomials"><a class="docs-heading-anchor" href="#bernstein-polynomials">Bernstein polynomials</a><a id="bernstein-polynomials-1"></a><a class="docs-heading-anchor-permalink" href="#bernstein-polynomials" title="Permalink"></a></h2><p>Because the Bernstein basis forms a partition of unity, computing the upper and lower bounds of a Bernstein polynomial is particularly simple and only requires evaluating the <code>extrema</code> of the Bernstein coefficients. Such a bound is usually much tighter than the bounds obtained by interval arithmetic. <code>ImplicitIntegration</code> provides a <code>BernsteinPolynomial</code> type that implements the interface described above; see the <code>bernstein.jl</code> file in <code>src</code> for the implementation details.</p><p>There are several ways to construct a <code>BernsteinPolynomial</code> object. The most direct one is to directly provide an array containing the Bernstein coefficients:</p><pre><code class="language-julia hljs">using ImplicitIntegration
lb = (-1.0, -1.0)
ub = (1.0, 1.0)
c  = rand(3,3) # Bernstein coefficients
p = ImplicitIntegration.BernsteinPolynomial(c, lb, ub)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Bernestein polynomial of degree (2, 2) on [-1.0,1.0] × [-1.0,1.0]</code></pre><p>The polynomial can now be evaluated at a point <code>x</code></p><pre><code class="language-julia hljs">x = (0.5, 0.5)
p(x)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0.27619542305111555</code></pre><p>or bounded over its domain:</p><pre><code class="language-julia hljs">ImplicitIntegration.bound(p)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(0.05020812266033736, 0.8372272809704018)</code></pre><p>Another way to create a <code>BernsteinPolynomial</code> is to interpolate a function over the grid points using <a href="../docstrings/#ImplicitIntegration.berninterp-Tuple{Type, Array, Any, Any}"><code>berninterp</code></a>, as illustrated below:</p><pre><code class="language-julia hljs">lb = (-1.0, -1.0)
ub = (1.0, 1.0)
npts = (4,4)
interp_pts = ImplicitIntegration.uniform_points(npts, lb, ub)
f = x -&gt; x[1]^2 + x[2]^2 - 1.0 # implicit function
p = ImplicitIntegration.berninterp(f.(interp_pts), lb, ub)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Bernestein polynomial of degree (3, 3) on [-1.0,1.0] × [-1.0,1.0]</code></pre><p>Since in this example <code>f</code> is itself a polynomial, and we interpolate it using a polynomial of higher degree, the interpolant should be exact (up to rounding errors):</p><pre><code class="language-julia hljs">using GLMakie
xx = lb[1]:0.05:ub[1]
yy = lb[2]:0.05:ub[2]
vals = [p((x,y)) - f((x,y)) for x in lb[1]:0.1:ub[1], y in lb[2]:0.1:ub[2]]
fig, ax, hm = heatmap(xx, yy, vals)
Colorbar(fig[1,2], hm; label = &quot;|p(x) - f(x)|&quot;, labelrotation = 0)</code></pre><img src="986106b4.png" alt="Example block output"/><p>!!! warning &quot;Increasing the interpolation degree&quot; The <code>berninterp</code> function illustrated     above performs polynomial interpolating using a Bernstein basis on a uniform grid. As is     well known, the Lebesgue constant for such interpolants grows exponentially with the     polynomial degree. In this package you usually want to use the <code>berninterp</code> function     with a fixed degree, and decrease <em>mesh size</em> parameter to obtain convergence. An     alternative, not yet implemented, is to interpolate the function on a Chebyshev grid,     and then convert the resulting Chebyshev polynomial into the Bernstein form.</p><p>Finally, <code>ImplicitIntegration</code> can automatically handle polynomials constructed using the <code>DynamicPolynomials.jl</code> package. When you use types from this package, the implicit function is automatically converted to a <code>BernsteinPolynomial</code> for bounds computation. This allows for efficient integration of polynomial implicit functions without requiring manual conversion to the Bernstein form. This specialization provides tighter bounds for the function value and its gradient, helping the recursive subdivision algorithm to stop earlier. The following example illustrates this difference in practice:</p><pre><code class="language-julia hljs">using ImplicitIntegration, StaticArrays
using GLMakie, LinearAlgebra, DynamicPolynomials
p1 = SVector(-1.0, 0)
p2 = SVector(1.0, 0)
b = 1.01
ϕ = x -&gt; (x - p1) ⋅ (x - p1) * (x - p2) ⋅ (x - p2) - b^2
@polyvar x y
poly = ((x,y) .- p1) ⋅ ((x,y) .- p1) * ((x,y) .- p2) ⋅ ((x,y) .- p2) - b^2
quad, logger = quadgen(ϕ, (-2, -2), (2, 2); order = 1, surface = true, loginfo=true)
quad_poly, logger_poly = quadgen(poly, (-2, -2), (2, 2); order = 1, surface = true, loginfo=true)
## plot
fig = Figure()
ax1 = Axis(fig[1, 1], aspect = DataAspect(), title = &quot;Default bounds&quot;, xlabel = &quot;x&quot;, ylabel = &quot;y&quot;)
scatter!(ax1, quad.coords, markersize = 10, color = :red)
plot!(ax1, logger)
ax2 = Axis(fig[1, 2], aspect = DataAspect(), title = &quot;Bernstein bounds&quot;, xlabel = &quot;x&quot;, ylabel = &quot;y&quot;)
scatter!(ax2, quad_poly.coords, markersize = 10, color = :red)
plot!(ax2, logger_poly)</code></pre><img src="38a7588c.png" alt="Example block output"/><p>The figure above illustrates the difference between using default bounds (based on interval arithmetic) and Bernstein polynomial bounds for quadrature generation (triggered by passing a <code>DynamicPolynomial.Poly</code> object to <code>quadgen</code>). The right panel shows how using Bernstein polynomial bounds results in more efficient and accurate quadrature points (red dots) around the zero level set of the implicit function. Note the significant reduction in the number of evaluated boxes and the tighter approximation of the curve.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../docstrings/">Docstrings »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.12.0 on <span class="colophon-date" title="Friday 13 June 2025 14:10">Friday 13 June 2025</span>. Using Julia version 1.11.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
