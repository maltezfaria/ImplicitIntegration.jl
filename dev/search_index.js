var documenterSearchIndex = {"docs":
[{"location":"specializations/#specializations","page":"Specializations","title":"Specializations","text":"","category":"section"},{"location":"specializations/","page":"Specializations","title":"Specializations","text":"details: Importance of tight bounds\nThe algorithm for implicit integration is described in [1] relies on the ability to compute bounds on the implicit function and its derivatives over a hyper-rectangle. Bounds on the implicit function are used to determine whether a box is empty or full, in which case a subdivision is not necessary. Bounds on the gradient are used to determine if a height direction exists for the dimensional reduction step, in which case the problem is recursively reduced to a lower dimension. If the algorithm is unable to prove that a box is empty, full, or that a height direction exists, it subdivides the box and repeats the process on the sub-boxes. The tightness of the bounds therefore directly affects the efficiency of the algorithm, as tighter bounds lead to fewer subdivisions.","category":"page"},{"location":"specializations/","page":"Specializations","title":"Specializations","text":"ImplicitIntegration provides a generic method for bounding functions and their derivatives using automatic differentiation via ForwardDiff and range estimation with IntervalArithmetic. While this approach has the advantage of being rather generic, the resulting bounds are often conservative and may lead to unnecessary subdivisions during the quadrature generation process.","category":"page"},{"location":"specializations/","page":"Specializations","title":"Specializations","text":"For specific classes of functions, we can leverage additional mathematical properties to compute tighter bounds more efficiently. These specialized bounds can significantly improve the performance of implicit integration, reducing both the computational cost and the number of quadrature points needed for accurate results.","category":"page"},{"location":"specializations/","page":"Specializations","title":"Specializations","text":"This section describes the interface for implementing custom bounds for specific function types, and discuss one such specialization already implemented in the package: Bernstein polynomials.","category":"page"},{"location":"specializations/#interface","page":"Specializations","title":"Interface","text":"","category":"section"},{"location":"specializations/","page":"Specializations","title":"Specializations","text":"To implement specialized bounds for a specific function type, you need to overload the following methods:","category":"page"},{"location":"specializations/","page":"Specializations","title":"Specializations","text":"bound(f::MyType, lc, hc) --> (fmin, fmax): Compute bounds for the function f over the hyperrectangle defined by lower corner lc and upper corner hc.\ngradient(f::MyType) --> ∇f: Compute the gradient of the function f as a function. The returned object ∇f should support evaluation on the form ∇f(x) where x is a point in the domain of f, and bound(∇f, lc, hc).\nproject(f, k, v): Project the function f onto the k-th coordinate using the value v. The returned object should support bound, gradient, and project methods, allowing it to be used in the same way as the original function.\nsplit(f, lb, ub, dir) --> fₗ, fᵤ: Split the function f along the specified direction dir into two parts, one for the lower half and one for the upper half of the hyperrectangle defined by lb and ub. The returned objects should also support bound, gradient, and project methods.","category":"page"},{"location":"specializations/","page":"Specializations","title":"Specializations","text":"tip: Disabling default implementations\nWhen implementing the interface for a specific function type, you may want to disable the default implementations provided by ImplicitIntegration to make sure you have correctly overloaded the proper methods. You can do this by calling disable_default_interface(). To re-enable the default interface, use enable_default_interface().","category":"page"},{"location":"specializations/#bernstein-polynomials","page":"Specializations","title":"Bernstein polynomials","text":"","category":"section"},{"location":"specializations/","page":"Specializations","title":"Specializations","text":"Because the Bernstein basis forms a partition of unity, computing the upper and lower bounds of a Bernstein polynomial is particularly simple and only requires evaluating the extrema of the Bernstein coefficients. Such a bound is usually much tighter than the bounds obtained by interval arithmetic. ImplicitIntegration provides a BernsteinPolynomial type that implements the interface described above; see the bernstein.jl file in src for the implementation details.","category":"page"},{"location":"specializations/","page":"Specializations","title":"Specializations","text":"There are several ways to construct a BernsteinPolynomial object. The most direct one is to directly provide an array containing the Bernstein coefficients:","category":"page"},{"location":"specializations/","page":"Specializations","title":"Specializations","text":"using ImplicitIntegration\nlb = (-1.0, -1.0)\nub = (1.0, 1.0)\nc  = rand(3,3) # Bernstein coefficients\np = ImplicitIntegration.BernsteinPolynomial(c, lb, ub)","category":"page"},{"location":"specializations/","page":"Specializations","title":"Specializations","text":"The polynomial can now be evaluated at a point x","category":"page"},{"location":"specializations/","page":"Specializations","title":"Specializations","text":"x = (0.5, 0.5)\np(x)","category":"page"},{"location":"specializations/","page":"Specializations","title":"Specializations","text":"or bounded over its domain:","category":"page"},{"location":"specializations/","page":"Specializations","title":"Specializations","text":"ImplicitIntegration.bound(p)","category":"page"},{"location":"specializations/","page":"Specializations","title":"Specializations","text":"Another way to create a BernsteinPolynomial is to interpolate a function over the grid points using berninterp, as illustrated below:","category":"page"},{"location":"specializations/","page":"Specializations","title":"Specializations","text":"lb = (-1.0, -1.0)\nub = (1.0, 1.0)\nnpts = (4,4)\ninterp_pts = ImplicitIntegration.uniform_points(npts, lb, ub)\nf = x -> x[1]^2 + x[2]^2 - 1.0 # implicit function\np = ImplicitIntegration.berninterp(f.(interp_pts), lb, ub)","category":"page"},{"location":"specializations/","page":"Specializations","title":"Specializations","text":"Since in this example f is itself a polynomial, and we interpolate it using a polynomial of higher degree, the interpolant should be exact (up to rounding errors):","category":"page"},{"location":"specializations/","page":"Specializations","title":"Specializations","text":"using GLMakie\n@assert all(abs(p((x,y)) - f((x,y))) < 1e-14 for x in lb[1]:0.1:ub[1], y in lb[2]:0.1:ub[2]) # hide\nxx = lb[1]:0.05:ub[1]\nyy = lb[2]:0.05:ub[2]\nvals = [p((x,y)) - f((x,y)) for x in lb[1]:0.1:ub[1], y in lb[2]:0.1:ub[2]]\nfig, ax, hm = heatmap(xx, yy, vals)\nColorbar(fig[1,2], hm; label = \"|p(x) - f(x)|\", labelrotation = 0)\ncurrent_figure() # hide","category":"page"},{"location":"specializations/","page":"Specializations","title":"Specializations","text":"!!! warning \"Increasing the interpolation degree\" The berninterp function illustrated     above performs polynomial interpolating using a Bernstein basis on a uniform grid. As is     well known, the Lebesgue constant for such interpolants grows exponentially with the     polynomial degree. In this package you usually want to use the berninterp function     with a fixed degree, and decrease mesh size parameter to obtain convergence. An     alternative, not yet implemented, is to interpolate the function on a Chebyshev grid,     and then convert the resulting Chebyshev polynomial into the Bernstein form.","category":"page"},{"location":"specializations/","page":"Specializations","title":"Specializations","text":"Finally, ImplicitIntegration can automatically handle polynomials constructed using the DynamicPolynomials.jl package. When you use types from this package, the implicit function is automatically converted to a BernsteinPolynomial for bounds computation. This allows for efficient integration of polynomial implicit functions without requiring manual conversion to the Bernstein form. This specialization provides tighter bounds for the function value and its gradient, helping the recursive subdivision algorithm to stop earlier. The following example illustrates this difference in practice:","category":"page"},{"location":"specializations/","page":"Specializations","title":"Specializations","text":"using ImplicitIntegration, StaticArrays\nusing GLMakie, LinearAlgebra, DynamicPolynomials\np1 = SVector(-1.0, 0)\np2 = SVector(1.0, 0)\nb = 1.01\nϕ = x -> (x - p1) ⋅ (x - p1) * (x - p2) ⋅ (x - p2) - b^2\n@polyvar x y\npoly = ((x,y) .- p1) ⋅ ((x,y) .- p1) * ((x,y) .- p2) ⋅ ((x,y) .- p2) - b^2\nquad, logger = quadgen(ϕ, (-2, -2), (2, 2); order = 1, surface = true, loginfo=true)\nquad_poly, logger_poly = quadgen(poly, (-2, -2), (2, 2); order = 1, surface = true, loginfo=true)\n## plot\nfig = Figure()\nax1 = Axis(fig[1, 1], aspect = DataAspect(), title = \"Default bounds\", xlabel = \"x\", ylabel = \"y\")\nscatter!(ax1, quad.coords, markersize = 10, color = :red)\nplot!(ax1, logger)\nax2 = Axis(fig[1, 2], aspect = DataAspect(), title = \"Bernstein bounds\", xlabel = \"x\", ylabel = \"y\")\nscatter!(ax2, quad_poly.coords, markersize = 10, color = :red)\nplot!(ax2, logger_poly)\ncurrent_figure() # hide","category":"page"},{"location":"specializations/","page":"Specializations","title":"Specializations","text":"The figure above illustrates the difference between using default bounds (based on interval arithmetic) and Bernstein polynomial bounds for quadrature generation (triggered by passing a DynamicPolynomial.Poly object to quadgen). The right panel shows how using Bernstein polynomial bounds results in more efficient and accurate quadrature points (red dots) around the zero level set of the implicit function. Note the significant reduction in the number of evaluated boxes and the tighter approximation of the curve.","category":"page"},{"location":"bibliography/#bibliography","page":"Bibliography","title":"Bibliography","text":"","category":"section"},{"location":"bibliography/","page":"Bibliography","title":"Bibliography","text":"R. I. Saye. High-order quadrature methods for implicitly defined surfaces and volumes in hyperrectangles. SIAM Journal on Scientific Computing 37, A993–A1019 (2015).\n\n\n\n","category":"page"},{"location":"#ImplicitIntegration","page":"Home","title":"ImplicitIntegration","text":"","category":"section"},{"location":"#overview","page":"Home","title":"Overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package provides an integrate function to approximate volume and surface integrals over implicitly defined domains in arbitrary dimensions. More specifically, it allows for the computation of volume integrals of the form","category":"page"},{"location":"","page":"Home","title":"Home","text":"    int_phi(boldsymbolx)  0  cap  U  f(boldsymbolx)  mathrmdV","category":"page"},{"location":"","page":"Home","title":"Home","text":"and surface integrals of the form","category":"page"},{"location":"","page":"Home","title":"Home","text":"    int_phi(boldsymbolx) = 0  cap  U  f(boldsymbolx)  mathrmdS","category":"page"},{"location":"","page":"Home","title":"Home","text":"where phi  mathbbR^d to mathbbR is a level-set function implicitly defining the surface, and U = a_1 b_1 times ldots times a_d b_d is a bounding HyperRectangle.","category":"page"},{"location":"","page":"Home","title":"Home","text":"tip: Algorithm\nThe algorithm implemented is based on [1], and relies on the ability to bound functions and their derivatives over hyperrectangles. Reading the paper is a good idea if you want to understand the details and limitations of the method.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To install the package, open the Julia REPL and run:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg; Pkg.add(\"ImplicitIntegration\");","category":"page"},{"location":"#Basic-usage","page":"Home","title":"Basic usage","text":"","category":"section"},{"location":"#integrate","page":"Home","title":"integrate","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The main function provided by this package is integrate, which computes implicit integrals using an adaptive quadrature method. Here is how you can use it to compute the volume of a sphere:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using ImplicitIntegration, StaticArrays\nϕ = (x) -> x[1]^2 + x[2]^2 + x[3]^2 - 1\nf = (x) -> 1\nlc = (-1.1, -1.1, -1.1)\nhc = (1.1, 1.1, 1.1)\nint_volume  = integrate(f, ϕ, lc, hc; loginfo = true)\nnothing # hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"The integrate function returns a NamedTuple object containing the value of the integral in val, as well as a logger object containing information about the computation:","category":"page"},{"location":"","page":"Home","title":"Home","text":"println(\"Computed volume:  $(int_volume.val)\")\nprintln(\"Error of volume:  $(int_volume.val - 4π/3)\")\nprintln(int_volume.logger)","category":"page"},{"location":"","page":"Home","title":"Home","text":"To compute a surface integral instead, simply set the surface keyword argument to true:","category":"page"},{"location":"","page":"Home","title":"Home","text":"int_surface = integrate(f, ϕ, lc, hc; surface = true, loginfo = true)\nprintln(\"Computed surface: $(int_surface.val)\")\nprintln(\"Error of surface: $(int_surface.val - 4π)\")\nprintln(int_surface.logger)","category":"page"},{"location":"","page":"Home","title":"Home","text":"It is also possible to visualize the computed tree structure by loading one of Makie's backends and calling the plot method on the logger object (mostly useful for debugging purposes):","category":"page"},{"location":"","page":"Home","title":"Home","text":"using GLMakie\n# plot the surface\nvv = [ϕ(SVector(x, y, z)) for x in lc[1]:0.1:hc[1], y in lc[2]:0.1:hc[1], z in lc[3]:0.1:hc[1]]\nvolume((lc[1], hc[1]), (lc[2], hc[2]), (lc[3], hc[3]), vv, algorithm = :iso, transparency = true, alpha = 0.4, isovalue = 0)\n# then the boxes\nplot!(int_surface.logger)\ncurrent_figure() # hide","category":"page"},{"location":"#quadgen","page":"Home","title":"quadgen","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"For situations where you need to compute the integrals of multiple functions over the same domain, you can use quadgen to generate a quadrature instead. It works similarly to integrate, but returns a Quadrature object instead of the integral value. Here is how to create a surface quadrature for a Cassini oval in 3D:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using ImplicitIntegration, StaticArrays\nusing GLMakie, LinearAlgebra\np1 = SVector(-1.0, 0, 0)\np2 = SVector(1.0, 0, 0)\nb = 1.1\nϕ = x -> (x - p1) ⋅ (x - p1) * (x - p2) ⋅ (x - p2) - b^2\nquad, logger = quadgen(ϕ, (-2, -2, -2), (2, 2, 2); order = 5, surface = true, loginfo=true)\nxx = yy = zz = range(-1.5, 1.5, length = 200)\nvv = ϕ.(SVector.(Iterators.product(xx, yy, zz)))\nvolume((xx[1],xx[end]), (yy[1],yy[end]), (zz[1],zz[end]), vv, algorithm = :iso, transparency = true, alpha = 0.4, isovalue = 0)\nscatter!(quad.coords, markersize = 2, color = :red)\ncurrent_figure() # hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"See the quadgen docstrings for more information on the available options.","category":"page"},{"location":"#Going-further","page":"Home","title":"Going further","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The basic usage examples above, as well as the docstrings for the integrate and quadgen functions, should be enough to get you started with the package. There are cases, however, where you may want to overload the default behavior for your custom types, and that is covered in the Specializations section. Of particular interest is the case where the implicit function is a polynomial, in which case ImplicitIntegration provides a special BernsteinPolynomial type that can be used to improve the performance of the integration and quadrature methods; see the Bernstein polynomials section for more details.","category":"page"},{"location":"docstrings/#docstrings","page":"Docstrings","title":"Docstrings","text":"","category":"section"},{"location":"docstrings/","page":"Docstrings","title":"Docstrings","text":"","category":"page"},{"location":"docstrings/#ImplicitIntegration.BernsteinPolynomial-Tuple{AbstractArray, Any, Any}","page":"Docstrings","title":"ImplicitIntegration.BernsteinPolynomial","text":"BernsteinPolynomial(c::AbstractArray, lc, hc)\n\nCreate a multidimensional Bernstein polynomial with coefficients c defined on the hyperrectangle [lc[1], hc[1]] × … × [lc[N], hc[N]].\n\nCalling p(x) evaluates the polynomial at the point x = (x[1], …, x[N]) by the formula\n\np(x_1dotsx_D)=sum_i_j=0^d_jc_i_1dots i_Dprod_j=1^Dbinomd_ji_j(x_j-l_j)^i_j(r_j-x_j)^d_j-i_j\n\nwhere l_j = lcj and r_j = hcj are the lower and upper bounds of the hyperrectangle, respectively, and d_j = size(c)j - 1 is the degree of the polynomial in dimension j.\n\nSee also berninterp.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#ImplicitIntegration.BernsteinPolynomial-Tuple{ImplicitIntegration.Polynomial, Any, Any}","page":"Docstrings","title":"ImplicitIntegration.BernsteinPolynomial","text":"BernsteinPolynomial(p::Polynomial, lb, ub)\n\nConvert a Polynomial p with coefficients in the monomial basis to a Bernstein polynomial on the domain defined by the lower corner lb and upper corner ub.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#ImplicitIntegration.CellType","page":"Docstrings","title":"ImplicitIntegration.CellType","text":"@enum CellType\n\nEnumeration for different types of cells. Options are full_cell, empty_cell, and partial_cell.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#ImplicitIntegration.Config","page":"Docstrings","title":"ImplicitIntegration.Config","text":"struct Config\n\nThe Config struct represents the configuration for implicit integration, passed to the integrate function to customize the behavior of the algorithm. It contains the following fields:\n\nfind_zero a function with signature (f, a, b, tol) --> x such that f(x) ≈ 0, a ≤ x ≤ b. The tolerance tol is used to specify the absolute tolerance of the zero approximation (e.g. xatol in Roots).\nquad: a function with signature quad(f, a, b, tol) --> (I,E) such that I approximates the integral of f over [a,b] and E is the estimated error. a and b Tuple(s)/SVector(s) specifying the lower and upper bounds of the integration domain, and tol is the desired absolute tolerance.\nmin_vol: a function with signature (tol) --> Float64 used to specify the volume of boxes below which the spatial subdivision stops. low-order method is used to approximate the integral.\nmin_qual: a number between 0 and 1 used to specify the minimum quality factor for a height direction to be considered valid for recursion. The quality factor for a direction k is given by |∂ₖϕ| / |∇ϕ|.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#ImplicitIntegration.GaussLegendre-Tuple{}","page":"Docstrings","title":"ImplicitIntegration.GaussLegendre","text":"GaussLegendre(; order, T = Float64)\n\nConstruct a Gauss-Legendre quadrature rule of given order with nodes and weights of type T, callable as quad1d(f, a, b) where f is the function to integrate and a and b are the bounds of the integration interval.\n\nExamples\n\nquad1d = ImplicitIntegration.GaussLegendre(; order = 20)\nquad1d(cos, 0, 1) ≈ sin(1)\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#ImplicitIntegration.HyperRectangle","page":"Docstrings","title":"ImplicitIntegration.HyperRectangle","text":"struct HyperRectangle{N,T<:AbstractFloat}\n\nA struct representing a hyperrectangle in N-dimensional space.\n\nFields\n\nlc::SVector{N,T}: The lower corner of the hyperrectangle.\nhc::SVector{N,T}: The upper corner of the hyperrectangle.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#ImplicitIntegration.LogInfo","page":"Docstrings","title":"ImplicitIntegration.LogInfo","text":"struct LogInfo\n\nA structure to store logging information for integration processes.\n\nFields\n\nsubdivisions::Vector{Int}: A vector containing the subdivisions per dimension used during the integration process.\nloworder::Int: The number of times the low-order method was used.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#ImplicitIntegration.LogInfo-Union{Tuple{ImplicitIntegration.HyperRectangle{N}}, Tuple{N}} where N","page":"Docstrings","title":"ImplicitIntegration.LogInfo","text":"LogInfo(U::HyperRectangle)\n\nInitialize a LogInfo object for integrating over U.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#ImplicitIntegration.Polynomial","page":"Docstrings","title":"ImplicitIntegration.Polynomial","text":"struct Polynomial{D,T}\n\nD-dimensional polynomial with coefficients of type T. The coefficients are stored as a dense array, and are implicitly associated with a monomial basis; i.e. the c[I] coefficient multiplies the monomial term prod(x.^(I .- 1)), where I is a D-dimensional multi-index.\n\nPassing a Dict{NTuple{N,Int},T} to the constructor will create a polynomial with coefficients given by c[k] for the monomial x₁^k[1] * x₂^k[2] * ... * x_N^k[N], where k is a multi-index of length N corresponding to the key, and c::T is the value associated with that key.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#ImplicitIntegration.Quadrature","page":"Docstrings","title":"ImplicitIntegration.Quadrature","text":"struct Quadrature{N,T}\n\nA collection of coords and weights for integration in N dimensions.\n\nQuadratures are the result of quadgen and can be used to integrate functions through integrate(f,::Quadrature).\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#ImplicitIntegration.Segment","page":"Docstrings","title":"ImplicitIntegration.Segment","text":"const Segment{T} = HyperRectangle{1,T}\n\nA one-dimensional hyperrectangle.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#ImplicitIntegration.TensorQuadrature","page":"Docstrings","title":"ImplicitIntegration.TensorQuadrature","text":"TensorQuadrature(quad1d)\n\nGiven a 1D quadrature rule quad1d with signature quad1d(f, a::Number, b::Number), return a tensor product quadrature rule callable through quadnd(f,a::SVector{N}, b::SVector{N}).\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#ImplicitIntegration.TreeNode","page":"Docstrings","title":"ImplicitIntegration.TreeNode","text":"mutable struct TreeNode\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#ImplicitIntegration._find_zeros!-Tuple{Any, Any, Any, ImplicitIntegration.HyperRectangle{1, T} where T, Vararg{Any, 4}}","page":"Docstrings","title":"ImplicitIntegration._find_zeros!","text":"_find_zeros!(roots, f, U::Segment, config, tol)\n\nReturn all zeros of the function f in the Segment U. f should be callable as f(x::SVector{1}).\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#ImplicitIntegration._integrand_eval-Union{Tuple{RET_TYPE}, Tuple{N}, Tuple{Any, Any, Any, Any, ImplicitIntegration.HyperRectangle{N}, Int64, Any, Type{RET_TYPE}, Any, Any, Any}} where {N, RET_TYPE}","page":"Docstrings","title":"ImplicitIntegration._integrand_eval","text":"_integrand_eval(f, phi_vec, s_vec, U, k, config, ::Type{RET_TYPE}, tol, logger)\n\nReturn a function f̃ : ℝᴺ⁻¹ -> ℝ that approximates the one-dimensional integral over I(x̃) ⊂ ℝ of the function t -> f(insert(x̃, k, t)), where the integration domain I is defined as I(x̃) = {t ∈ [a,b] : sᵢ*ϕᵢ(insert(̃x,k,t) ≥ 0 ∀ (ϕᵢ,sᵢ) ∈ V)}.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#ImplicitIntegration._monomial_to_bernstein-Tuple{Any, Any, Any}","page":"Docstrings","title":"ImplicitIntegration._monomial_to_bernstein","text":"_monomial_to_bernstein(c::Array, lb, ub)\n\nConvert a polynomial with coefficients c in the monomial basis to a Bernstein polynomial on the hyperrectangle defined by lb and ub.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#ImplicitIntegration.berninterp-Tuple{Type, Array, Any, Any}","page":"Docstrings","title":"ImplicitIntegration.berninterp","text":"berninterp([T=Float64,] vals::Array, lb, ub)\n\nConstruct a Bernstein polynomial of that interpolates the values vals at the points given by uniform_points(size(vals), lb, ub), where lb and ub are the lower and upper corners of the hyperrectangle on which the polynomial is defined.\n\nThe optional type parameter T specifies the precision used for computing the polynomial coefficients.\n\nExamples\n\nusing StaticArrays\nf = (x) -> (1 - x[1])^2 + x[1]^4 + x[2]^5 * x[1]^3\nlb = SVector(0.1, -0.3)\nub = SVector(1.2, 1.7)\npts = ImplicitIntegration.uniform_points((5, 6), lb, ub)\nvals = f.(pts)\np = ImplicitIntegration.berninterp(vals, lb, ub)\nx = lb .+ (ub - lb) .* rand(SVector{2})\nf(x) ≈ p(x)\n\n# output\n\ntrue\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#ImplicitIntegration.berninterp-Tuple{Type, Vararg{Any, 4}}","page":"Docstrings","title":"ImplicitIntegration.berninterp","text":"berninterp([T=Float64,] f, n, lb, ub)\n\nConstruct a Bernstein polynomial of degree n that interpolates the function f at the points given by uniform_points(n, lb, ub), where lb and ub are the lower and upper corners of the hyperrectangle on which the polynomial is defined. The optional type parameter T specifies the precision used for computing the polynomial coefficients.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#ImplicitIntegration.bernstein_interp","page":"Docstrings","title":"ImplicitIntegration.bernstein_interp","text":"bernstein_interp(vals, pts, lb, ub)\n\nConstruct a Bernstein polynomial on (lb[1], ub[1]) × … × (lb[N], ub[N]) that interpolates the values vals at the points pts. Note that vals and pts...\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#ImplicitIntegration.bound-Tuple{Any, Any, Any}","page":"Docstrings","title":"ImplicitIntegration.bound","text":"bound(f, lc, hc) --> (lb, ub)\n\nReturn a lower and upper bound for the function f : U → ℝ valid for all x ∈ U.\n\nbound(∇f, lc, hc) --> bnds\n\nCompute a lower and upper bound for the gradient of a function f : U → ℝ valid for all x ∈ U in the sense that bnds[i][1] ≤ ∂f/∂xᵢ(x) ≤ bnds[i][2].\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#ImplicitIntegration.bound-Tuple{ImplicitIntegration.BernsteinPolynomial}","page":"Docstrings","title":"ImplicitIntegration.bound","text":"bound(p::BernsteinPolynomial)\n\nReturn the bounds of the Bernstein polynomial p as a tuple (m, M), where m is a lower bound and M is an upper bound on the polynomial's values over the hyperrectangle with corners low_corner(p) and high_corner(p).\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#ImplicitIntegration.bounds-Tuple{ImplicitIntegration.HyperRectangle}","page":"Docstrings","title":"ImplicitIntegration.bounds","text":"bounds(rect::HyperRectangle)\n\nGet the lower and upper bounds of a HyperRectangle.\n\nArguments\n\nrect::HyperRectangle: The HyperRectangle object.\n\nReturns\n\nA tuple (lc, hc) representing the lower and upper bounds of the HyperRectangle.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#ImplicitIntegration.cell_type-NTuple{4, Any}","page":"Docstrings","title":"ImplicitIntegration.cell_type","text":"cell_type(ϕ, s, U, surface)\n\nCompute the CellType of a cell defined by the level-set function ϕ, a sign s, and the box U. If surface is true, then the cell is classified as per a surface integral.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#ImplicitIntegration.derivative-Union{Tuple{N}, Tuple{ImplicitIntegration.BernsteinPolynomial{N}, Int64}} where N","page":"Docstrings","title":"ImplicitIntegration.derivative","text":"derivative(p::BernsteinPolynomial, d::Int)g\n\nCompute the derivative along dimension d of the Bernstein polynomial p, returning a new BernsteinPolynomial of the same dimension N.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#ImplicitIntegration.disable_default_interface-Tuple{}","page":"Docstrings","title":"ImplicitIntegration.disable_default_interface","text":"disable_default_interface()\n\nThrow an error if the default interface is used, to ensure that all methods are implemented for a given function type. This is useful for testing purposes.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#ImplicitIntegration.enable_default_interface-Tuple{}","page":"Docstrings","title":"ImplicitIntegration.enable_default_interface","text":"enable_default_interface()\n\nRe-enable the default interface, so that the generic bound, gradient, project, and split methods can be used with functions that do not implement these methods.\n\nSee also disable_default_interface.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#ImplicitIntegration.gradient-Tuple{Any}","page":"Docstrings","title":"ImplicitIntegration.gradient","text":"gradient(f)\n\nCompute the gradient function f : ℝᵈ → ℝ. The returned function takes a vector x ∈ ℝᵈ and returns the gradient ∇f(x) ∈ ℝᵈ.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#ImplicitIntegration.integrate-Union{Tuple{T}, Tuple{N}, Tuple{Any, Any, StaticArraysCore.SVector{N, T}, StaticArraysCore.SVector{N, T}}} where {N, T}","page":"Docstrings","title":"ImplicitIntegration.integrate","text":"integrate(f, ϕ, lc, hc; tol=1e-8, surface=false, config = Config(), loginfo = false) -->\n(val, logger)\n\nIntegrate the function f over an implicit domain defined by:\n\nΩ = {lc ≤ 𝐱 ≤ hc: ϕ(𝐱) < 0} if surface = false\nΓ = {lc ≤ 𝐱 ≤ hc: ϕ(𝐱) = 0} if surface = true\n\nwhere lc and hc denote the lower and upper corners of the bounding box.\n\ntol specifies the desired (absolute) tolerance for the approximation.\n\nThe function returns a named tuple (val, logger) where val is the approximated value, and logger is a LogInfo object containing information about the integration process if loginfo = true; otherwise, logger is nothing.\n\nFor a finer control over the integration process, pass a config object (see Config).\n\nNote that both f and ϕ must be callable with a single argument 𝐱 of type SVector. Furthemore, ϕ is expected to return a real value.\n\nSee also quadgen if you want to generate a quadrature instead of directly computing the value of the integral.\n\nBy default, ImplicitIntegration uses ForwardDiff to compute gradients and IntervalArithmetic to compute bounds, both of which are needed for the algorithm to work. While these work reasonably well in most cases, you may want to overload the following methods for the type of your input function ϕ:\n\nϕ(x::SVector{N,<:Real}) -> Real to evaluate the level-set function at x.\nϕ(xI::SVector{N,<:Interval{<:Real}}) -> Interval{<:Real} to evaluate a bound on ϕ on the interval xI.\nϕ(xD::SVector{N,Dual{N,<:Real}}) -> Dual{N,<:Real} to evaluate the level-set function and its gradient at x.\nϕ(xDI::SVector{N,Dual{N,<:Interval{<:Real}}}) -> Dual{N,<:Interval{<:Real}} to evaluate a bound on ϕ and its gradient on the interval xDI.\n\nYou may need to overload the methods above if typeof(ϕ) is not supported by ForwardDiff and/or IntervalArithmetic, or if you have a better/faster implementation; see the main docs.\n\nExamples\n\nTo compute the area of a quarter of a disk of radius 1.0:\n\na, b = (0.0, 0.0), (1.5, 1.5)\nϕ = (x) -> x[1]^2 + x[2]^2 - 1\nf = (x) -> 1.0\nres = integrate(f, ϕ, a, b) # area of quarter of a disk\nres.val ≈ π / 4\n\nTo compute the perimeter of a quarter of a circle of radius 1.0:\n\na, b = (0.0, 0.0), (1.5, 1.5)\nϕ = (x) -> x[1]^2 + x[2]^2 - 1\nf = (x) -> 1.0\nres = integrate(x -> 1.0, ϕ, a, b; surface = true) # perimeter of quarter of a circle\nres.val ≈ 2π / 4\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#ImplicitIntegration.integrate-Union{Tuple{T}, Tuple{N}, Tuple{Any, ImplicitIntegration.Quadrature{N, T}}} where {N, T}","page":"Docstrings","title":"ImplicitIntegration.integrate","text":"integrate(f, Q::Quadrature)\n\nShorthand for ∑ᵢf(xᵢ)wᵢ, where xᵢ and wᵢ are the nodes and weights of the Quadrature.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#ImplicitIntegration.lift_all_dims-Tuple{ImplicitIntegration.TreeNode}","page":"Docstrings","title":"ImplicitIntegration.lift_all_dims","text":"lift_all_dims(root::TreeNode)\n\nLift all nodes in root to the same dimension as root.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#ImplicitIntegration.lift_dim-Tuple{Any, Any}","page":"Docstrings","title":"ImplicitIntegration.lift_dim","text":"lift_dim(node, dim)\n\nLift all boxes of dimension dim in the tree rooted at node to the same dimension as their parent.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#ImplicitIntegration.lift_node_and_children-Tuple{ImplicitIntegration.TreeNode, Any, Any, Any}","page":"Docstrings","title":"ImplicitIntegration.lift_node_and_children","text":"lift_node_and_children(node::TreeNode, dim, lb, ub)\n\nLift each box in the tree rooted at node by appending lb and ub to the dim-th dimension of the box.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#ImplicitIntegration.lower_restrict-Union{Tuple{T}, Tuple{D}, Tuple{ImplicitIntegration.BernsteinPolynomial{D, T}, Integer}} where {D, T}","page":"Docstrings","title":"ImplicitIntegration.lower_restrict","text":"lower_restrict(p::BernsteinPolynomial{D}, d::Integer) where {D}\n\nRestricts the given BernsteinPolynomial p to the lower face (i.e., where the d-th coordinate is at its lower bound) along the specified dimension d. Returns a new BernsteinPolynomial of dimension D-1 representing the restriction.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#ImplicitIntegration.project-Tuple{Any, Any, Any}","page":"Docstrings","title":"ImplicitIntegration.project","text":" project(f, k, v)\n\nGiven a function f : ℝᵈ → ℝ, a value v ∈ ℝ and an integer 1 ≤ k ≤ d, return the function f̃ : ℝᵈ⁻¹ → ℝ defined by projecting f onto the hyperplane xₖ = v; i.e. f̃(x) = f(x₁, ..., x_{k-1}, v, x_{k}, ..., x_d).\n\nnote: Note\nThe returned type should also implement the interface methods gradient, bound.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#ImplicitIntegration.quadgen-Union{Tuple{T}, Tuple{N}, Tuple{Any, StaticArraysCore.SVector{N, T}, StaticArraysCore.SVector{N, T}}} where {N, T}","page":"Docstrings","title":"ImplicitIntegration.quadgen","text":"quadgen(ϕ, lc, hc; order, surface, kwargs...)\n\nSimilar to integrate, but generate a Quadrature over an implict domain defined by:\n\nΩ = {lc ≤ 𝐱 ≤ hc: ϕ(𝐱) < 0} if surface = false\nΓ = {lc ≤ 𝐱 ≤ hc: ϕ(𝐱) = 0} if surface = true\n\norder specifies the degree of exactness of the quadrature rule; that is, the quadrature rule will integrate exactly polynomials of degree up to order, but not order+1. A GaussLegendre quadrature rule is used.\n\nThe function returns a named tuple (quad, logger) where quad contains the generated Quadrature, and logger is a LogInfo object containing information about the integration process.\n\nSee integrate for more information on the available kwargs.\n\nExamples\n\nTo compute the area of a quarter of a disk of radius 1.0:\n\na, b = (0.0, 0.0), (1.5, 1.5)\nϕ = (x) -> x[1]^2 + x[2]^2 - 1\nf = (x) -> 1.0\nout = quadgen(ϕ, a, b; order = 20)\nintegrate(f, out.quad) ≈ π / 4 # area of quarter of a disk\n\nTo compute the perimeter of a quarter of a circle of radius 1.0:\n\na, b = (0.0, 0.0), (1.5, 1.5)\nϕ = (x) -> x[1]^2 + x[2]^2 - 1\nf = (x) -> 1.0\nout = quadgen(ϕ, a, b; order = 20, surface = true)\nQ = out.quad\nintegrate(f, Q) ≈ 2π / 4 # perimeter of quarter of a circle\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#ImplicitIntegration.reference_vandermonde_matrix-Tuple{Any, Any}","page":"Docstrings","title":"ImplicitIntegration.reference_vandermonde_matrix","text":"reference_vandermonde_matrix([T=Float64,] n)\n\nVandermond matrix for Bernstein interpolation on uniform_points(n, lb, ub), with lb = (0, … , 0) and ub = (1, … , 1). The ordering of the basis elements is the same as in the evaluation of the Bernstein polynomial. The optional type parameter T specifies the element type of the matrix.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#ImplicitIntegration.remove_dimension-Tuple{ImplicitIntegration.HyperRectangle, Any}","page":"Docstrings","title":"ImplicitIntegration.remove_dimension","text":"remove_dimension(rect::HyperRectangle, k)\n\nRemove a dimension from a HyperRectangle by deleting the k-th element from the lower and upper corners.\n\nArguments\n\nrect::HyperRectangle: The input hyperrectangle.\nk: The index of the dimension to be removed.\n\nReturns\n\nA new HyperRectangle with the k-th dimension removed.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#ImplicitIntegration.sgn-Tuple{Any, Any, Bool, Any}","page":"Docstrings","title":"ImplicitIntegration.sgn","text":"sgn(m, s, S::Bool, σ)\n\nHelper function to compute the sign of lower and upper restrictions of a level-set function ϕᵢ in a box along a given height direction k. Here m is sign of ∂ₖϕᵢ, which is assume not to change throughout the box since k is assumed to be a height direction, s is the sign of ϕᵢ in the box, S is a flag to indicate whether we are in the special case of a surface integral.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#ImplicitIntegration.split-NTuple{4, Any}","page":"Docstrings","title":"ImplicitIntegration.split","text":"split(f, lb, ub)\n\nGiven a function f : ℝᵈ → ℝ and lower and upper bounds lb, ub ∈ ℝᵈ, return the restriction of f to the hyperrectangle defined by lb and ub.\n\nBy default this function simply returns f, but it computing sharper bounds on the restricted function requires a more sophisticated implementation.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#ImplicitIntegration.split-Tuple{ImplicitIntegration.HyperRectangle, Any}","page":"Docstrings","title":"ImplicitIntegration.split","text":"split(U::HyperRectangle, dir)\n\nSplit a hyperrectangle U along the specified direction dir.\n\nArguments\n\nU::HyperRectangle: The hyperrectangle to be split.\ndir: The direction along which to split the hyperrectangle.\n\nReturns\n\nUₗ: The left half of the split hyperrectangle.\nUᵣ: The right half of the split hyperrectangle.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#ImplicitIntegration.split-Union{Tuple{T}, Tuple{D}, Tuple{ImplicitIntegration.BernsteinPolynomial{D, T}, Integer}, Tuple{ImplicitIntegration.BernsteinPolynomial{D, T}, Integer, Any}} where {D, T}","page":"Docstrings","title":"ImplicitIntegration.split","text":"split(p::BernsteinPolynomial, d::Integer, α = 0.5) --> pₗ, pᵣ\n\nSplit the Bernstein polynomial p along dimension d at lc[d] + (hc[d] - lc[d]) * α, where lc and hc are the lower and upper corners of the hyperrectangle on which p is defined. Returns two new Bernstein polynomials pₗ and pᵣ representing the left and right polynomials.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#ImplicitIntegration.uniform_points-Tuple{Any}","page":"Docstrings","title":"ImplicitIntegration.uniform_points","text":"uniform_points(n[, lc, hc])\n\nGenerate n[1] × … × n[D] uniformly spaced points in the hyperrectangle defined by (lc[1], hc[1]) × … × (lc[D], hc[D]), where D = length(n) = length(lc) = length(hc). By default lc = (0, … , 0) and hc = (1, … , 1), generating n[1] × … × n[D] points in the unit hypercube [0, 1]^D.\n\nThe points are returned as an array, of size n, containing SVector of dimension D.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#ImplicitIntegration.upper_restrict-Union{Tuple{T}, Tuple{D}, Tuple{ImplicitIntegration.BernsteinPolynomial{D, T}, Integer}} where {D, T}","page":"Docstrings","title":"ImplicitIntegration.upper_restrict","text":"upper_restrict(p::BernsteinPolynomial{D}, d::Integer) where {D}\n\nSame as lower_restrict, but restricts to the upper face (i.e., where the d-th coordinate is at its upper bound)\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#ImplicitIntegration.use_heuristic_bounds","page":"Docstrings","title":"ImplicitIntegration.use_heuristic_bounds","text":"use_heuristic_bounds(F::Type, n = 10)\n\nOverload interface methods for type F to use a sample-based heuristic when bounding functions of type F and its gradient.\n\nThe bounds are obtained by sampling the function (or its gradient) on an n × ... × n grid and taking the maximum/minimum of the attained values. This is obviously a heuristic, and may fail in practice.\n\n\n\n\n\n","category":"function"}]
}
