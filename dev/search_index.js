var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = ImplicitIntegration","category":"page"},{"location":"#ImplicitIntegration","page":"Home","title":"ImplicitIntegration","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for ImplicitIntegration.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [ImplicitIntegration]","category":"page"},{"location":"#ImplicitIntegration.CellType","page":"Home","title":"ImplicitIntegration.CellType","text":"@enum CellType\n\nEnumeration for different types of cells. Options are full_cell, empty_cell, and partial_cell.\n\n\n\n\n\n","category":"type"},{"location":"#ImplicitIntegration.Config","page":"Home","title":"ImplicitIntegration.Config","text":"struct Config\n\nThe Config struct represents the configuration for implicit integration, passed to the integrate function to customize the behavior of the algorithm.\n\nThe Config struct has the following fields:\n\nfind_zero: called as find_zero(f, a, b), returns a zero of f in the interval [a,b] (if it exists).\nfind_zeros: called as find_zeros(f, a, b), returns all zeros of f in the interval [a,b] (if they exist).\nquad: called as quad(f, a::SVector, b::SVector), returns an approximation to the integral of f over [HyperRectangle(a,b)(@ref)].\nmin_qual: a number between 0 and 1 used to specify the minimum quality factor for a height direction to be considered good for recursion. The quality factor for a direction k is given by |‚àÇ‚Çñœï| / |‚àáœï|.\nmin_size: a number used to specify the minimum size of a box to be split during the recursion. Recursion stops when the box is smaller than this size.\n\n\n\n\n\n","category":"type"},{"location":"#ImplicitIntegration.HyperRectangle","page":"Home","title":"ImplicitIntegration.HyperRectangle","text":"struct HyperRectangle{N,T<:AbstractFloat}\n\nA struct representing a hyperrectangle in N-dimensional space.\n\nFields\n\nlc::SVector{N,T}: The lower corner of the hyperrectangle.\nhc::SVector{N,T}: The upper corner of the hyperrectangle.\n\n\n\n\n\n","category":"type"},{"location":"#ImplicitIntegration.Segment","page":"Home","title":"ImplicitIntegration.Segment","text":"const Segment{T} = HyperRectangle{1,T}\n\nA one-dimensional hyperrectangle.\n\n\n\n\n\n","category":"type"},{"location":"#ImplicitIntegration.SubFunction","page":"Home","title":"ImplicitIntegration.SubFunction","text":"struct SubFunction{M,N,T,F}\n\nRepresents a function fÃÉ : ‚Ñù·¥π ‚Üí ‚Ñù given by restricting N coordinates of another function f : ‚Ñù·¥π‚Å∫·¥∫ ‚Üí ‚Ñù to fixed values.\n\nFields\n\nf::F: The underlying function.\ndims::SVector{N,Int}: The dimensions to restrict.\nvals::SVector{N,T}: The values on the restricted dimensions.\n\nThe type parameter M has to be explicitly provided (e.g. SubFunction{M}(f, dims, vals)) since it cannot be inferred from the fields.\n\n\n\n\n\n","category":"type"},{"location":"#ImplicitIntegration._integrand_eval-Union{Tuple{RET_TYPE}, Tuple{N}, Tuple{Any, Any, Any, ImplicitIntegration.HyperRectangle{N}, Int64, Any, Type{RET_TYPE}, Any}} where {N, RET_TYPE}","page":"Home","title":"ImplicitIntegration._integrand_eval","text":"_integrand_eval(f, V::ImplicitDomain{N}, dir, quad1d)\n\nReturn a function fÃÉ : ‚Ñù·¥∫‚Åª¬π -> ‚Ñù that approximates the one-dimensional integral over I(xÃÉ) ‚äÇ ‚Ñù of the function t -> f(insert(xÃÉ, k, t)), where the integration domain I is defined as I(xÃÉ) = {t ‚àà [a,b] : s·µ¢*œï·µ¢(insert(ÃÉx,k,t) ‚â• 0 ‚àÄ (œï·µ¢,s·µ¢) ‚àà V)}.\n\n\n\n\n\n","category":"method"},{"location":"#ImplicitIntegration.bound-Union{Tuple{N}, Tuple{Any, ImplicitIntegration.HyperRectangle{N}}} where N","page":"Home","title":"ImplicitIntegration.bound","text":"bound(f, U::HyperRectangle) --> (lb, ub)\n\nReturn a lower and upper bound for the function f : U ‚Üí ‚Ñù valid for all x ‚àà U.\n\n\n\n\n\n","category":"method"},{"location":"#ImplicitIntegration.bound_gradient-Union{Tuple{N}, Tuple{Any, ImplicitIntegration.HyperRectangle{N}}} where N","page":"Home","title":"ImplicitIntegration.bound_gradient","text":"bound_gradient(f, U::HyperRectangle) --> (lbs, ubs)\n\nCompute a lower and upper bound for the gradient of a function f : U ‚Üí ‚Ñù valid for all x ‚àà U in the sense that lbs[i] ‚â§ ‚àÇf/‚àÇx·µ¢(x) ‚â§ ubs[i].\n\n\n\n\n\n","category":"method"},{"location":"#ImplicitIntegration.bounds-Tuple{ImplicitIntegration.HyperRectangle}","page":"Home","title":"ImplicitIntegration.bounds","text":"bounds(rect::HyperRectangle)\n\nGet the lower and upper bounds of a HyperRectangle.\n\nArguments\n\nrect::HyperRectangle: The HyperRectangle object.\n\nReturns\n\nA tuple (lc, hc) representing the lower and upper bounds of the HyperRectangle.\n\n\n\n\n\n","category":"method"},{"location":"#ImplicitIntegration.cell_type-NTuple{4, Any}","page":"Home","title":"ImplicitIntegration.cell_type","text":"cell_type(œï, s, U, surface)\n\nCompute the CellType of a cell defined by the level-set function œï, a sign s, and the box U. If surface is true, then the cell is classified as per a surface integral.\n\n\n\n\n\n","category":"method"},{"location":"#ImplicitIntegration.gradient-Tuple{Any, Any}","page":"Home","title":"ImplicitIntegration.gradient","text":"gradient(f, x)\n\nCompute the gradient of a function f : ‚Ñù·µà ‚Üí ‚Ñù at point x ‚àà ‚Ñù·µà.\n\n\n\n\n\n","category":"method"},{"location":"#ImplicitIntegration.integrate-Union{Tuple{T}, Tuple{N}, Tuple{Any, Any, StaticArraysCore.SVector{N, T}, StaticArraysCore.SVector{N, T}}} where {N, T}","page":"Home","title":"ImplicitIntegration.integrate","text":"integrate(f, œï, lc, hc; tol=1e-8, surface=false, config = Config())\n\nIntegrate the function f over an implict domain defined by:\n\nŒ© = {lc ‚â§ ùê± ‚â§ hc: œï(ùê±) < 0} if surface = false\nŒì = {lc ‚â§ ùê± ‚â§ hc: œï(ùê±) = 0} if surface = true\n\nwhere lc::NTuple and hc::NTuple denote the lower and upper corners of the bounding box.\n\ntol specifies the desired (absolute) tolerance for the approximation.\n\nFor a finer control of the integration process, the user can pass a config object to customize the behavior of various aspects of the algorithm (see Config for more details).\n\nNote that both f and œï must be callable with a single argument ùê± of type SVector. Furthemore, œï is expected to return a real value.\n\nExamples\n\nTo compute the area of a quarter of a disk of radius 1.0:\n\na, b = (0.0, 0.0), (1.5, 1.5)\nœï = (x) -> x[1]^2 + x[2]^2 - 1\nf = (x) -> 1.0\nintegrate(f, œï, a, b) ‚âà œÄ / 4 # area of quarter of a disk\n\nTo compute the perimeter of a quarter of a circle of radius 1.0:\n\na, b = (0.0, 0.0), (1.5, 1.5)\nœï = (x) -> x[1]^2 + x[2]^2 - 1\nf = (x) -> 1.0\nintegrate(x -> 1.0, œï, a, b; surface = true) ‚âà 2œÄ / 4 # perimeter of quarter of a circle\n\n\n\n\n\n","category":"method"},{"location":"#ImplicitIntegration.multi_insert-Union{Tuple{CHECK}, Tuple{M}, Tuple{StaticArraysCore.SVector, StaticArraysCore.SVector{M, Int64}, StaticArraysCore.SVector{M}}, Tuple{StaticArraysCore.SVector, StaticArraysCore.SVector{M, Int64}, StaticArraysCore.SVector{M}, Val{CHECK}}} where {M, CHECK}","page":"Home","title":"ImplicitIntegration.multi_insert","text":"multi_insert(x::SVector{N,T}, idxs::SVector{M,Int}, vals::SVector{M,T}, ::Val{CHECK})\n\nLike StaticArrays.insert, but inserts multiple values into x.\n\nPassing a sorted idxs together with Val(false) for CHECK can be used to assert that idxs is sorted without actually checking it.\n\n\n\n\n\n","category":"method"},{"location":"#ImplicitIntegration.remove_dimension-Tuple{ImplicitIntegration.HyperRectangle, Any}","page":"Home","title":"ImplicitIntegration.remove_dimension","text":"remove_dimension(rect::HyperRectangle, k)\n\nRemove a dimension from a HyperRectangle by deleting the k-th element from the lower and upper corners.\n\nArguments\n\nrect::HyperRectangle: The input hyperrectangle.\nk: The index of the dimension to be removed.\n\nReturns\n\nA new HyperRectangle with the k-th dimension removed.\n\n\n\n\n\n","category":"method"},{"location":"#ImplicitIntegration.sgn-Tuple{Any, Any, Bool, Any}","page":"Home","title":"ImplicitIntegration.sgn","text":"sgn(m, s, S::Bool, œÉ)\n\nHelper function to compute the sign of lower and upper restrictions of a level-set function œï·µ¢ in a box along a given height direction k. Here m is sign of ‚àÇ‚Çñœï·µ¢, which is assume not to change throughout the box since k is assumed to be a height direction, s is the sign of œï·µ¢ in the box, S is a flag to indicate whether we are in the special case of a surface integral.\n\n\n\n\n\n","category":"method"},{"location":"#ImplicitIntegration.split-Tuple{ImplicitIntegration.HyperRectangle, Any}","page":"Home","title":"ImplicitIntegration.split","text":"split(U::HyperRectangle, dir)\n\nSplit a hyperrectangle U along the specified direction dir.\n\nArguments\n\nU::HyperRectangle: The hyperrectangle to be split.\ndir: The direction along which to split the hyperrectangle.\n\nReturns\n\nU‚Çó: The left half of the split hyperrectangle.\nU·µ£: The right half of the split hyperrectangle.\n\n\n\n\n\n","category":"method"}]
}
