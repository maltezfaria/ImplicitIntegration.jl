var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = ImplicitIntegration","category":"page"},{"location":"#ImplicitIntegration","page":"Home","title":"ImplicitIntegration","text":"","category":"section"},{"location":"#Overview","page":"Home","title":"Overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package provides an integrate function to approximate volume and surface integrals over implicitly defined domains in arbitrary dimensions. The algorithm is based on [1].","category":"page"},{"location":"","page":"Home","title":"Home","text":"More specifically, it allows for the computation of volume integrals of the form","category":"page"},{"location":"","page":"Home","title":"Home","text":"    int_phi(boldsymbolx)  0  cap  U  f(boldsymbolx)  mathrmdV","category":"page"},{"location":"","page":"Home","title":"Home","text":"and surface integrals of the form","category":"page"},{"location":"","page":"Home","title":"Home","text":"    int_phi(boldsymbolx) = 0  cap  U  f(boldsymbolx)  mathrmdS","category":"page"},{"location":"","page":"Home","title":"Home","text":"where phi  mathbbR^d to mathbbR is a level-set function, and U = a_1 b_1 times ldots times a_d b_d is a bounding HyperRectangle.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Since the package is not yet registered, you can install it by running","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg; Pkg.add(\"https://github.com/maltezfaria/ImplicitIntegration.jl\");","category":"page"},{"location":"#Basic-usage","page":"Home","title":"Basic usage","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The main function provided by this package is integrate:","category":"page"},{"location":"","page":"Home","title":"Home","text":"integrate","category":"page"},{"location":"#ImplicitIntegration.integrate","page":"Home","title":"ImplicitIntegration.integrate","text":"integrate(f, œï, lc, hc; tol=1e-8, surface=false, config = Config())\n\nIntegrate the function f over an implict domain defined by:\n\nŒ© = {lc ‚â§ ùê± ‚â§ hc: œï(ùê±) < 0} if surface = false\nŒì = {lc ‚â§ ùê± ‚â§ hc: œï(ùê±) = 0} if surface = true\n\nwhere lc::NTuple and hc::NTuple denote the lower and upper corners of the bounding box.\n\ntol specifies the desired (absolute) tolerance for the approximation.\n\nFor a finer control of the integration process, the user can pass a config object to customize the behavior of various aspects of the algorithm (see Config for more details). In such cases the tol parameter is ignored and config.quad is used for the integration.\n\nNote that both f and œï must be callable with a single argument ùê± of type SVector. Furthemore, œï is expected to return a real value.\n\nSee also quadgen if you want to generate a quadrature instead of direcly computing the value of the integral.\n\nExamples\n\nTo compute the area of a quarter of a disk of radius 1.0:\n\na, b = (0.0, 0.0), (1.5, 1.5)\nœï = (x) -> x[1]^2 + x[2]^2 - 1\nf = (x) -> 1.0\nintegrate(f, œï, a, b) ‚âà œÄ / 4 # area of quarter of a disk\n\nTo compute the perimeter of a quarter of a circle of radius 1.0:\n\na, b = (0.0, 0.0), (1.5, 1.5)\nœï = (x) -> x[1]^2 + x[2]^2 - 1\nf = (x) -> 1.0\nintegrate(x -> 1.0, œï, a, b; surface = true) ‚âà 2œÄ / 4 # perimeter of quarter of a circle\n\n\n\n\n\nintegrate(f, Q::Quadrature)\n\nShorthand for ‚àë·µ¢f(x·µ¢)w·µ¢, where x·µ¢ and w·µ¢ are the nodes and weights of the Quadrature.\n\n\n\n\n\n","category":"function"},{"location":"","page":"Home","title":"Home","text":"For situations where you need to compute the integrals of multiple functions over the same domain, you can use the quadgen function to generate a quadrature instead:","category":"page"},{"location":"","page":"Home","title":"Home","text":"quadgen","category":"page"},{"location":"#ImplicitIntegration.quadgen","page":"Home","title":"ImplicitIntegration.quadgen","text":"quadgen(œï, lc, hc; order, surface=false, config = nothing)\n\nReturn a Quadrature to integrate a function over an implict domain defined by:\n\nŒ© = {lc ‚â§ ùê± ‚â§ hc: œï(ùê±) < 0} if surface = false\nŒì = {lc ‚â§ ùê± ‚â§ hc: œï(ùê±) = 0} if surface = true\n\nwhere lc::NTuple and hc::NTuple denote the lower and upper corners of the bounding box.\n\nThe order parameter specifies the degree of exactness of the quadrature rule; that is, the quadrature rule will integrate exactly polynomials of degree up to order, but not order+1. A GaussLegendre quadrature rule is used.\n\nFor a finer control of the integration process, the user can pass a config object to customize the behavior of various aspects of the algorithm (see Config for more details). In such cases, the order parameter is ignored and config.quad is used for the integration.\n\nNote that œï must be callable with a single argument ùê± of type SVector. Furthemore, œï is expected to return a real value.\n\nExamples\n\nTo compute the area of a quarter of a disk of radius 1.0:\n\na, b = (0.0, 0.0), (1.5, 1.5)\nœï = (x) -> x[1]^2 + x[2]^2 - 1\nf = (x) -> 1.0\nQ = quadgen(œï, a, b; order = 20)\nintegrate(f, Q) ‚âà œÄ / 4 # area of quarter of a disk\n\nTo compute the perimeter of a quarter of a circle of radius 1.0:\n\na, b = (0.0, 0.0), (1.5, 1.5)\nœï = (x) -> x[1]^2 + x[2]^2 - 1\nf = (x) -> 1.0\nQ = quadgen(œï, a, b; order = 20, surface = true)\nintegrate(f, Q) ‚âà 2œÄ / 4 # perimeter of quarter of a circle\n\n\n\n\n\n","category":"function"},{"location":"#Bibliography","page":"Home","title":"Bibliography","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"R.¬†I.¬†Saye. High-order quadrature methods for implicitly defined surfaces and volumes in hyperrectangles. SIAM¬†Journal¬†on¬†Scientific¬†Computing 37, A993‚ÄìA1019 (2015).\n\n\n\n","category":"page"},{"location":"docstrings/","page":"Docstrings","title":"Docstrings","text":"CurrentModule = ImplicitIntegration","category":"page"},{"location":"docstrings/#Docstrings","page":"Docstrings","title":"Docstrings","text":"","category":"section"},{"location":"docstrings/","page":"Docstrings","title":"Docstrings","text":"","category":"page"},{"location":"docstrings/","page":"Docstrings","title":"Docstrings","text":"Modules = [ImplicitIntegration]","category":"page"},{"location":"docstrings/#ImplicitIntegration.CellType","page":"Docstrings","title":"ImplicitIntegration.CellType","text":"@enum CellType\n\nEnumeration for different types of cells. Options are full_cell, empty_cell, and partial_cell.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#ImplicitIntegration.Config","page":"Docstrings","title":"ImplicitIntegration.Config","text":"struct Config\n\nThe Config struct represents the configuration for implicit integration, passed to the integrate function to customize the behavior of the algorithm.\n\nThe Config struct has the following fields:\n\nfind_zero: called as find_zero(f, a, b), returns a zero of f in the interval [a,b] (if it exists).\nfind_zeros: called as find_zeros(f, a, b), returns all zeros of f in the interval [a,b] (if they exist).\nquad: called as quad(f, a::SVector, b::SVector), returns an approximation to the integral of f over [HyperRectangle(a,b)(@ref)].\nmin_qual: a number between 0 and 1 used to specify the minimum quality factor for a height direction to be considered good for recursion. The quality factor for a direction k is given by |‚àÇ‚Çñœï| / |‚àáœï|.\nmin_size: a number used to specify the minimum size of a box to be split during the recursion. Recursion stops when the box is smaller than this size.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#ImplicitIntegration.GaussLegendre-Tuple{}","page":"Docstrings","title":"ImplicitIntegration.GaussLegendre","text":"GaussLegendre(; order, T = Float64)\n\nConstruct a Gauss-Legendre quadrature rule of given order with nodes and weights of type T, callable as quad1d(f, a, b) where f is the function to integrate and a and b are the bounds of the integration interval.\n\nExamples\n\nquad1d = ImplicitIntegration.GaussLegendre(;order = 20)\nquad1d(cos,0,1) ‚âà sin(1)\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#ImplicitIntegration.HyperRectangle","page":"Docstrings","title":"ImplicitIntegration.HyperRectangle","text":"struct HyperRectangle{N,T<:AbstractFloat}\n\nA struct representing a hyperrectangle in N-dimensional space.\n\nFields\n\nlc::SVector{N,T}: The lower corner of the hyperrectangle.\nhc::SVector{N,T}: The upper corner of the hyperrectangle.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#ImplicitIntegration.Quadrature","page":"Docstrings","title":"ImplicitIntegration.Quadrature","text":"struct Quadrature{N,T}\n\nA collection of coords and weights for integration in N dimensions.\n\nQuadratures are the result of quadgen and can be used to integrate functions through integrate(f,::Quadrature).\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#ImplicitIntegration.Segment","page":"Docstrings","title":"ImplicitIntegration.Segment","text":"const Segment{T} = HyperRectangle{1,T}\n\nA one-dimensional hyperrectangle.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#ImplicitIntegration.SubFunction","page":"Docstrings","title":"ImplicitIntegration.SubFunction","text":"struct SubFunction{M,N,T,F}\n\nRepresents a function fÃÉ : ‚Ñù·¥π ‚Üí ‚Ñù given by restricting N coordinates of another function f : ‚Ñù·¥π‚Å∫·¥∫ ‚Üí ‚Ñù to fixed values.\n\nFields\n\nf::F: The underlying function.\ndims::SVector{N,Int}: The dimensions to restrict.\nvals::SVector{N,T}: The values on the restricted dimensions.\n\nThe type parameter M has to be explicitly provided (e.g. SubFunction{M}(f, dims, vals)) since it cannot be inferred from the fields.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#ImplicitIntegration.TensorQuadrature","page":"Docstrings","title":"ImplicitIntegration.TensorQuadrature","text":"TensorQuadrature(quad1d)\n\nGiven a 1D quadrature rule quad1d with signature quad1d(f, a::Number, b::Number), return a tensor product quadrature rule callable through quadnd(f,a::SVector{N}, b::SVector{N}).\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#ImplicitIntegration._integrand_eval-Union{Tuple{RET_TYPE}, Tuple{N}, Tuple{Any, Any, Any, ImplicitIntegration.HyperRectangle{N}, Int64, Any, Type{RET_TYPE}, Any}} where {N, RET_TYPE}","page":"Docstrings","title":"ImplicitIntegration._integrand_eval","text":"_integrand_eval(f, V::ImplicitDomain{N}, dir, quad1d)\n\nReturn a function fÃÉ : ‚Ñù·¥∫‚Åª¬π -> ‚Ñù that approximates the one-dimensional integral over I(xÃÉ) ‚äÇ ‚Ñù of the function t -> f(insert(xÃÉ, k, t)), where the integration domain I is defined as I(xÃÉ) = {t ‚àà [a,b] : s·µ¢*œï·µ¢(insert(ÃÉx,k,t) ‚â• 0 ‚àÄ (œï·µ¢,s·µ¢) ‚àà V)}.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#ImplicitIntegration.bound-Tuple{Any, Any}","page":"Docstrings","title":"ImplicitIntegration.bound","text":"bound(f, U::HyperRectangle) --> (lb, ub)\n\nReturn a lower and upper bound for the function f : U ‚Üí ‚Ñù valid for all x ‚àà U.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#ImplicitIntegration.bound_gradient-Tuple{Any, Any}","page":"Docstrings","title":"ImplicitIntegration.bound_gradient","text":"bound_gradient(f, U::HyperRectangle) --> bnds\n\nCompute a lower and upper bound for the gradient of a function f : U ‚Üí ‚Ñù valid for all x ‚àà U in the sense that bnds[i][1] ‚â§ ‚àÇf/‚àÇx·µ¢(x) ‚â§ bnds[i][2].\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#ImplicitIntegration.bounds-Tuple{ImplicitIntegration.HyperRectangle}","page":"Docstrings","title":"ImplicitIntegration.bounds","text":"bounds(rect::HyperRectangle)\n\nGet the lower and upper bounds of a HyperRectangle.\n\nArguments\n\nrect::HyperRectangle: The HyperRectangle object.\n\nReturns\n\nA tuple (lc, hc) representing the lower and upper bounds of the HyperRectangle.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#ImplicitIntegration.cell_type-NTuple{4, Any}","page":"Docstrings","title":"ImplicitIntegration.cell_type","text":"cell_type(œï, s, U, surface)\n\nCompute the CellType of a cell defined by the level-set function œï, a sign s, and the box U. If surface is true, then the cell is classified as per a surface integral.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#ImplicitIntegration.find_zeros-Union{Tuple{T}, Tuple{Any, ImplicitIntegration.HyperRectangle{<:, T}}, Tuple{Any, ImplicitIntegration.HyperRectangle{<:, T}, Any}} where T","page":"Docstrings","title":"ImplicitIntegration.find_zeros","text":"find_zeros(f, U::HyperRectangle{<:,T}, config = Config()) where {T}\n\nReturn all zeros of the function f in the box U. f should be callable as f(x::SVector).\n\nThe config argument can be used to customize the behavior of the algorithm by passing a different find_zero method (e.g. Roots.find_zero) and a different min_size to control the interval length at which the recursion gives up trying to find all zeros and resorts instead to a heuristic.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#ImplicitIntegration.gradient-Tuple{Any, Any}","page":"Docstrings","title":"ImplicitIntegration.gradient","text":"gradient(f, x)\n\nCompute the gradient of a function f : ‚Ñù·µà ‚Üí ‚Ñù at point x ‚àà ‚Ñù·µà.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#ImplicitIntegration.integrate-Union{Tuple{T}, Tuple{N}, Tuple{Any, Any, StaticArraysCore.SVector{N, T}, StaticArraysCore.SVector{N, T}}} where {N, T}","page":"Docstrings","title":"ImplicitIntegration.integrate","text":"integrate(f, œï, lc, hc; tol=1e-8, surface=false, config = Config())\n\nIntegrate the function f over an implict domain defined by:\n\nŒ© = {lc ‚â§ ùê± ‚â§ hc: œï(ùê±) < 0} if surface = false\nŒì = {lc ‚â§ ùê± ‚â§ hc: œï(ùê±) = 0} if surface = true\n\nwhere lc::NTuple and hc::NTuple denote the lower and upper corners of the bounding box.\n\ntol specifies the desired (absolute) tolerance for the approximation.\n\nFor a finer control of the integration process, the user can pass a config object to customize the behavior of various aspects of the algorithm (see Config for more details). In such cases the tol parameter is ignored and config.quad is used for the integration.\n\nNote that both f and œï must be callable with a single argument ùê± of type SVector. Furthemore, œï is expected to return a real value.\n\nSee also quadgen if you want to generate a quadrature instead of direcly computing the value of the integral.\n\nExamples\n\nTo compute the area of a quarter of a disk of radius 1.0:\n\na, b = (0.0, 0.0), (1.5, 1.5)\nœï = (x) -> x[1]^2 + x[2]^2 - 1\nf = (x) -> 1.0\nintegrate(f, œï, a, b) ‚âà œÄ / 4 # area of quarter of a disk\n\nTo compute the perimeter of a quarter of a circle of radius 1.0:\n\na, b = (0.0, 0.0), (1.5, 1.5)\nœï = (x) -> x[1]^2 + x[2]^2 - 1\nf = (x) -> 1.0\nintegrate(x -> 1.0, œï, a, b; surface = true) ‚âà 2œÄ / 4 # perimeter of quarter of a circle\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#ImplicitIntegration.integrate-Union{Tuple{T}, Tuple{N}, Tuple{Any, ImplicitIntegration.Quadrature{N, T}}} where {N, T}","page":"Docstrings","title":"ImplicitIntegration.integrate","text":"integrate(f, Q::Quadrature)\n\nShorthand for ‚àë·µ¢f(x·µ¢)w·µ¢, where x·µ¢ and w·µ¢ are the nodes and weights of the Quadrature.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#ImplicitIntegration.multi_insert-Union{Tuple{CHECK}, Tuple{M}, Tuple{StaticArraysCore.SVector, StaticArraysCore.SVector{M, Int64}, StaticArraysCore.SVector{M}}, Tuple{StaticArraysCore.SVector, StaticArraysCore.SVector{M, Int64}, StaticArraysCore.SVector{M}, Val{CHECK}}} where {M, CHECK}","page":"Docstrings","title":"ImplicitIntegration.multi_insert","text":"multi_insert(x::SVector{N,T}, idxs::SVector{M,Int}, vals::SVector{M,T}, ::Val{CHECK})\n\nLike StaticArrays.insert, but inserts multiple values into x.\n\nPassing a sorted idxs together with Val(false) for CHECK can be used to assert that idxs is sorted without actually checking it.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#ImplicitIntegration.quadgen-Union{Tuple{T}, Tuple{N}, Tuple{Any, StaticArraysCore.SVector{N, T}, StaticArraysCore.SVector{N, T}}} where {N, T}","page":"Docstrings","title":"ImplicitIntegration.quadgen","text":"quadgen(œï, lc, hc; order, surface=false, config = nothing)\n\nReturn a Quadrature to integrate a function over an implict domain defined by:\n\nŒ© = {lc ‚â§ ùê± ‚â§ hc: œï(ùê±) < 0} if surface = false\nŒì = {lc ‚â§ ùê± ‚â§ hc: œï(ùê±) = 0} if surface = true\n\nwhere lc::NTuple and hc::NTuple denote the lower and upper corners of the bounding box.\n\nThe order parameter specifies the degree of exactness of the quadrature rule; that is, the quadrature rule will integrate exactly polynomials of degree up to order, but not order+1. A GaussLegendre quadrature rule is used.\n\nFor a finer control of the integration process, the user can pass a config object to customize the behavior of various aspects of the algorithm (see Config for more details). In such cases, the order parameter is ignored and config.quad is used for the integration.\n\nNote that œï must be callable with a single argument ùê± of type SVector. Furthemore, œï is expected to return a real value.\n\nExamples\n\nTo compute the area of a quarter of a disk of radius 1.0:\n\na, b = (0.0, 0.0), (1.5, 1.5)\nœï = (x) -> x[1]^2 + x[2]^2 - 1\nf = (x) -> 1.0\nQ = quadgen(œï, a, b; order = 20)\nintegrate(f, Q) ‚âà œÄ / 4 # area of quarter of a disk\n\nTo compute the perimeter of a quarter of a circle of radius 1.0:\n\na, b = (0.0, 0.0), (1.5, 1.5)\nœï = (x) -> x[1]^2 + x[2]^2 - 1\nf = (x) -> 1.0\nQ = quadgen(œï, a, b; order = 20, surface = true)\nintegrate(f, Q) ‚âà 2œÄ / 4 # perimeter of quarter of a circle\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#ImplicitIntegration.remove_dimension-Tuple{ImplicitIntegration.HyperRectangle, Any}","page":"Docstrings","title":"ImplicitIntegration.remove_dimension","text":"remove_dimension(rect::HyperRectangle, k)\n\nRemove a dimension from a HyperRectangle by deleting the k-th element from the lower and upper corners.\n\nArguments\n\nrect::HyperRectangle: The input hyperrectangle.\nk: The index of the dimension to be removed.\n\nReturns\n\nA new HyperRectangle with the k-th dimension removed.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#ImplicitIntegration.sgn-Tuple{Any, Any, Bool, Any}","page":"Docstrings","title":"ImplicitIntegration.sgn","text":"sgn(m, s, S::Bool, œÉ)\n\nHelper function to compute the sign of lower and upper restrictions of a level-set function œï·µ¢ in a box along a given height direction k. Here m is sign of ‚àÇ‚Çñœï·µ¢, which is assume not to change throughout the box since k is assumed to be a height direction, s is the sign of œï·µ¢ in the box, S is a flag to indicate whether we are in the special case of a surface integral.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#ImplicitIntegration.split-Tuple{ImplicitIntegration.HyperRectangle, Any}","page":"Docstrings","title":"ImplicitIntegration.split","text":"split(U::HyperRectangle, dir)\n\nSplit a hyperrectangle U along the specified direction dir.\n\nArguments\n\nU::HyperRectangle: The hyperrectangle to be split.\ndir: The direction along which to split the hyperrectangle.\n\nReturns\n\nU‚Çó: The left half of the split hyperrectangle.\nU·µ£: The right half of the split hyperrectangle.\n\n\n\n\n\n","category":"method"}]
}
